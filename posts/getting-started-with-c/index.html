<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title></title>
<link rel="stylesheet" href="../../assets/main.css">
</head>
<body>
<div><header class="header">
                        <span class="header__inner">
                                <div class="logo">
  <span class="logo__mark">></span>
  <span class="logo__text">cd ~</span>
  <span class="logo__cursor"
  style="background-color:#ffffff;animation-duration:0.75s;">
  </span>
</div>

                                    <span class="header__right">
                                        <nav class="menu">
  <ul class="menu__inner">
    <li><a href="/">Home</a></li>
    <li><a href="/posts/">Drafts</a></li>
    <li><a href="/projects/">Projects</a></li>
  </ul>
</nav>

                                    </span>
                        </span>
                        </header><div style="margin: 0 auto; width: 850px;
                border: 1px solid black; padding: 50px;
                margin-top: 100px; text-align: left;
                font-size: 14px">
                <h1>Introduction</h1>
<p>The C programming language was first developed in the 1970s by Dennis Ritchie a Bell Labs. The language was inspired by its predecessor B and eventually would be standardized by the American National Standards Institute (ANSI) in the 1980s. The C programming language is a relatively low-level programming language which means that, as the programmer, you are required to do most of the leg work that is done automatically by higher level languages like Python. Practically speaking, we have to take memory management into our own hands when programming in C. This makes it very easy to shoot yourself in the foot as the programmer, but it also allows you program just about anything. This is by no means a comprehensive guide; it is only meant to be a rough overview of the language. The C Programming Language textbook is a great resources if you want to learn the ins and outs of the language.</p>
<h1>Hello World</h1>
<p>Let's start with the hello world program in C. First, we must import the header file stdio.h, which handles basic input and output from the keyboard and display, respectively. Then we define the function main() which is required in every C program. In C, we are given the option of including the return type of the program before the function name but if our function does not return anything we can omit this. Lastly, we make a function call to <em>printf()</em>, where the f stands for format. This is the standard function used for printing to the console and we will see of an example of formatting in the next section. </p>
<pre><code class="c">#include &lt;stdio.h&gt;

main() {

    printf(&quot;Hello World&quot;);

}
</code></pre>

<pre><code>Hello World
</code></pre>
<h1>Defining variables</h1>
<p>The first instance of this that we will encounter is in the definition of variables and their data types. This comes down to what is called <em>static typing</em> and <em>dynamic typing</em>  and there is a nice thread on this <a href="https://stackoverflow.com/questions/1517582/what-is-the-difference-between-statically-typed-and-dynamically-typed-languages">here</a>, but the tl;dr version is just that statically typed languages, like C, require the programmer to explicitly specify the data type of a particular variable when it is defined. Dynamically typed languages, like Python, have a system for inferring the type of a variable. Let's see this in action by creating a Farhenheit-Celsius table.</p>
<pre><code class="c">
</code></pre>

<pre><code>0   -17
20  -6
40  4
60  15
80  26
100 37
120 48
140 60
160 71
180 82
200 93
220 104
240 115
260 126
280 137
300 148
</code></pre>
<p>In the code above you can see that we defined five different variables: fahr, celsius, lower, upper, and step. Each of these is an integer so is preceded by <em>int</em>. The rest is just a standard while loop for incrementing the temperature in fahrenheit. </p>
<h1>Data types in C</h1>
<p>Of course, there are other data types available for use in C. You can even define your own custom data types but we won't discuss that here. Anyway, we can arrange some of the commonly used data types in a table:</p>
<p>| Type  | Storage | Value Range |
| ----  | ------- | ----------- |
| char  | 1 byte | -128 to 127 or 0 to 255 |
| unsigned char  | 1 byte | 0 to 255 |
| signed char | 1 byte | -128 to 127 |
| int  | 2 or 4 bytes | -32,768 to 32,767 or -2,147,483,648 to 2,147,483,647 |
| unsigned int  | 2 or 4 bytes | 0 to 65,535 or 0 to 4,294,967,295 |
| float  | 4 bytes | 1.2E-38 to 3.4E+38 |
| double  | 8 bytes | 2.3E-308 to 1.7E+308 |
| short | 2 bytes | -32,768 to 32,767 |
| unsigned short | 2 bytes | 0 to 65,535|
| long | 8 bytes | -9223372036854775808 to 9223372036854775807 |
| unsigned long | 8 bytes | 0 to 18446744073709551615 |</p>
<p>This is by no means a comprehensive list, but its a good start. Let's verify this table by writing a program that defines a variable of each of these types and prints number of bytes allocated for it by using the sizeof function():</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main() {

    char a_char; 
    unsigned char a_uchar;
    signed char a_schar;
    int a_int; 
    unsigned int a_uint;
    float a_float;
    double a_double;
    short a_short;
    unsigned short a_ushort;
    long a_long;
    unsigned long a_ulong;


    printf(&quot;The size of char is %zu byte(s)\n&quot;, sizeof(a_char));
    printf(&quot;The size of unsigned char is %zu byte(s)\n&quot;, sizeof(a_uchar));
    printf(&quot;The size of signed char is %zu byte(s)\n&quot;, sizeof(a_schar));
    printf(&quot;The size of int is %zu byte(s)\n&quot;, sizeof(a_int));
    printf(&quot;The size of unsigned int is %zu byte(s)\n&quot;, sizeof(a_uint));
    printf(&quot;The size of a float is %zu byte(s)\n&quot;, sizeof(a_float));
    printf(&quot;The size of a double is %zu byte(s)\n&quot;, sizeof(a_double));
    printf(&quot;The size of short is %zu byte(s)\n&quot;, sizeof(a_short));
    printf(&quot;The size of unsigned short is %zu byte(s)\n&quot;, sizeof(a_ushort));
    printf(&quot;The size of long is %zu byte(s)\n&quot;, sizeof(a_long));
    printf(&quot;The size of unsigned long is %zu byte(s)\n&quot;, sizeof(a_ulong));


}
</code></pre>

<pre><code>The size of char is 1 byte(s)
The size of unsigned char is 1 byte(s)
The size of signed char is 1 byte(s)
The size of int is 4 byte(s)
The size of unsigned int is 4 byte(s)
The size of a float is 4 byte(s)
The size of a double is 8 byte(s)
The size of short is 2 byte(s)
The size of unsigned short is 2 byte(s)
The size of long is 8 byte(s)
The size of unsigned long is 8 byte(s)
</code></pre>
<h1>Looping</h1>
<p>To learn the syntax for looping in C, we will write a Fahrenheit-Celsius conversion program which can also be found in the standard  C Programming Language textbook. </p>
<h2>While-Loops</h2>
<p>The standard syntax for a while loop is while(condition){do something}. We can utilize our newfound knowledge of variable definitions to set some bounds on the while-loop.</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main() {

    int fahr, celsius;
    int lower, upper, step;

    lower = 0; /* lower limit of temp table */
    upper = 300; /* upper limit of temp table */
    step = 20; /* step size */

    fahr = lower;

    while (fahr &lt;= upper){

        celsius = 5 * (fahr - 32) / 9;
        printf(&quot;%d\t%d\n&quot;, fahr, celsius);
        fahr = fahr + step;

    }   
}
</code></pre>

<pre><code>0   -17
20  -6
40  4
60  15
80  26
100 37
120 48
140 60
160 71
180 82
200 93
220 104
240 115
260 126
280 137
300 148
</code></pre>
<h2>For-Loops</h2>
<p>Let's write the same program using a for-loop this time. The standard syntax for a for-loop is for(lower bound; upper bound; increment){do something}. In place of 'lower bound' we set some initial condition for the counter that will be modified in the body of the loop. Upper bound is of course the value the counter will take it the loops last iteration, and the increment determines how much the counter is incremented at each iteration. In this case, the counter is the temperature on a fahrenheit scale.</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main() {

    int fahr, celsius;
    int lower, upper, step;

    lower = 0; /* lower limit of temp table */
    upper = 300; /* upper limit of temp table */
    step = 20; /* step size */

    fahr = lower;

    for (fahr = lower; fahr &lt;= upper; fahr = fahr + step){

        celsius = 5 * (fahr - 32) / 9;
        printf(&quot;%d\t%d\n&quot;, fahr, celsius);
    }

}
</code></pre>

<pre><code>0   -17
20  -6
40  4
60  15
80  26
100 37
120 48
140 60
160 71
180 82
200 93
220 104
240 115
260 126
280 137
300 148
</code></pre>
<h1>Arrays</h1>
<h2>Character Arrays</h2>
<p>In this next section, we will focus on arrays and their implementation in C. This brings up an interesting topic: there is no such thing as a string at this level, rather, strings are implemented as arrays of characters. So we can defined a string by defining an array and assigning its elements as the characters of string like 'bananas'.</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main() {

    char mystr[7] = &quot;bananas&quot;;
    printf(&quot;The size of '%s' is %zu byte(s)\n&quot;, mystr, sizeof(mystr));

}
</code></pre>

<pre><code>The size of 'bananas' is 7 byte(s)
</code></pre>
<h2>Integer Arrays</h2>
<p>Arrays of integers are defined in a similar way; however, you cannot print the entire array as we did with the character array above. You have to iterate through the array and call printf() for each element. </p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main() {

    int ndigits = 5;
    int i;
    int digits[ndigits];

    for (i = 0; i &lt;= ndigits; i++){

        digits[i] = i;
        printf(&quot;%d\n&quot;, digits[i]);

    }    
}
</code></pre>

<pre><code>0
1
2
3
4
5
</code></pre>
<h1>Control Flow</h1>
<p>Another indispensible tool in C programming is the use of control-flow that will determine the behavior of the program given certain inputs. One useful example of this involves using control flow to determine whether a variable is an integer or alphabetical character. This kind of control flow could be very useful when reading raw data from files and parsing the content. </p>
<pre><code class="c">#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main(){

   int var1 = 'a';
   int var2 = '5';


   /* Check variable 1 */
   if(isdigit(var1)) {
      printf(&quot;var1 = |%c| is a digit\n&quot;, var1);
   } else if (isalpha(var1)){
      printf(&quot;var1 = |%c| is an alphabetical character\n&quot;, var1);
   }

   /* Check variable 2 */
   if(isdigit(var2)){
      printf(&quot;var2 = |%c| is a digit\n&quot;, var2);
   } else if (isalpha(var2)){
      printf(&quot;var2= |%c| is an alphabetical character\n&quot;, var2);
   }
}
</code></pre>

<pre><code>var1 = |a| is an alphabetical character
var2 = |5| is a digit
</code></pre>
<h1>Functions &amp; Arguments</h1>
<p>I really like how the C Programming Language textbook describes the philosophy of a function. The author writes: "With properly defined functions, it is possible to ignore <em>how</em> a job is done; knowing <em>what</em> is done is sufficient. Thus far, we've utilized functions like printf(), isdigit(), etc.; now, we'd like to define some functions of our own. When defining user functions in C, we have to use a <em>function prototype</em> which is typically one line of code that includes three things: the function's return type, name, and arguments. For example if we want to define a function that performs multiplication, it's prototype would look like: float sqrt(float m, float n);. Then, we can write out the body of the function and invoke it in main.</p>
<pre><code class="c">#include &lt;stdio.h&gt;

float mult(float m, float n);

int main(){

    float m, n, p;
    m = 5; 
    n = 2;
    p = mult(m,n);
    printf(&quot;The product is: %f&quot;, p);

}

float mult(float m, float n){

    float p; 
    p = m*n;
    return(p);


}
</code></pre>

<pre><code>The product is: 10.000000
</code></pre>
<h1>Pointers and Address Arithmetic</h1>
<h1>Pointers</h1>
<p>A pointer in C is a variable that contains the address of another variable. To really understand pointers and why
they are useful, it is necessary to understand how RAM in a computer is organized. RAM is typically an array of memory cells which are numbered consecutively. That address is usually in hexadecimal format. To define a pointer, we precede the pointer name with an asterisk. If b is the variable containing the pointer and type is the data type of the variable that b will point to. For example, we can assign the address of a variable a to another variable b. Also, we can access and modify what is stored in a via the <em>indirection</em> or <em>dereferencing</em> operator This is best shown by example:</p>
<pre><code class="c">#include &lt;stdio.h&gt;


int main(){

    int a, c, *b;

    a = 5;
    b = &amp;a; 

    printf(&quot;The variable a is located at: %p\n&quot;, b); 
    printf(&quot;The contents of a is: %d\n&quot;, *b);

    c = *b;
    *b += 5;
    ++*b;

    printf(&quot;The contents of a is: %d\n&quot;, *b);
    printf(&quot;The contents of c is: %d&quot;, c);

}

</code></pre>

<pre><code>The variable a is located at: 0x7ffe7b87f988
The contents of a is: 5
The contents of a is: 11
The contents of c is: 5
</code></pre>
<p>As you can see, we can assign the address of a to the pointer b. Then, we can copy what is contained in a to another variable c by using the indirection operator. After that, we modify a using the same operator, keeping c intact. Moving on, pointers become especially important when passing variables to a function you want to modify the original variables. In C, arguments are passed to functions <em>by value</em> meaning that when you pass, say, an integer to a function you pass only a <em>copy</em> of that integer to the function. Therefore, the function has no way of modifying the variable itself. There is a good example of how to reconcile this issue with pointers in the C Programming Language textbook. We will define a function swap(), which will take to variables and swap their values. First, we will try it the wrong way and then we will show how pointers make it work correctly. </p>
<pre><code class="c">#include &lt;stdio.h&gt;

void swap(int x, int y){

    int temp; 
    temp = x;
    x = y; 
    y = temp;

}


int main(){

    int x,y; 
    x = 1; 
    y = 2;

    swap(x, y);
    printf(&quot;The variable x contains: %d\n&quot;, x); 
    printf(&quot;The variable y contains: %d\n&quot;, y); 

}
</code></pre>

<pre><code>The variable x contains: 1
The variable y contains: 2
</code></pre>
<pre><code class="c">As you can see, nothing happened. Now let's try it the correct way by using pointers to x and y.
</code></pre>

<pre><code class="c">#include &lt;stdio.h&gt;

void swap(int *px, int *py){

    int temp; 
    temp = *px;
    *px = *py; 
    *py = temp;

}


int main(){

    int x,y; 
    x = 1; 
    y = 2;

    swap(&amp;x, &amp;y);
    printf(&quot;The variable x contains: %d\n&quot;, x); 
    printf(&quot;The variable y contains: %d\n&quot;, y); 

}
</code></pre>

<pre><code>The variable x contains: 2
The variable y contains: 1
</code></pre>
<h1>Address Arithmetic</h1>
<p>In its most basic form, address arithmetic allows you to define a pointer to a particular location in memory and then increment that pointer to arrive at neighboring memory locations. This is especially useful if you want to allocate a block of memory addresses for storage. In the code below, we will allocate a block of memory allocbuf that will fit ALLOCSIZE characters. The user can then call the function alloc() to allocate chunks of allocbuf for their storage needs.   </p>
<pre><code class="c">#define ALLOCSIZE 10000

static char allocbuf[ALLOCSIZE]; /* array of characters */
static char *allocp = &amp;allocbuf[0]; /* initialize pointer to start of allocbuf */

char *alloc(int n){

    if(allocbuf + ALLOCSIZE - allocp &gt;= n){ /* check if n chars will fit */
        allocp += n;
        return allocp - n; 

    } else {

        return 0; /* signal that there is no space */
    }

}

void afree(char *p){

    if (p &gt;= allocbuf &amp;&amp; p &lt; allocbuf + ALLOCSIZE){

        allocp = p;

    }

}
</code></pre>

<p>Notice the alloc() checks first to see if n characters will fit in allocbuf. If their request can be fulfilled, n is added to the pointer allocp and allocp - n is returned so the user has the starting point for their block of memory. Recall that allocp is a global variable so successive calls to alloc() will affect allocp permanently. Finally, afree() can be used to free memory beyond a memory location p. It does this by simply reassigning the pointer allocp to the memory location beyond which memory should be freed. These functions are implemented in the standard library (but more robustly) as malloc() and free().</p>
                </div>
                 <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
                        <script type="text/javascript" id="MathJax-script" async
                        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
                        <script type="text/javascript" src="assets/main.js"></script></div></body>
</html>
