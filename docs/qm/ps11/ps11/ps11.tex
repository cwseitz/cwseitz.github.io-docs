\documentclass[12pt]{article}
\usepackage{amsmath} % AMS Math Package
\usepackage{bm}
\usepackage{amsthm} % Theorem Formatting
\usepackage{amssymb}    % Math symbols such as \mathbb
\usepackage{graphicx} % Allows for eps images
\usepackage[dvips,letterpaper,margin=1in,bottom=0.7in]{geometry}
\usepackage{tensor}
\usepackage{amsmath}
\usepackage{siunitx}
\usepackage{physics}
\usepackage{algorithm}
\usepackage{amsmath, amssymb, graphics, setspace}

\newcommand{\mathsym}[1]{{}}
\newcommand{\unicode}[1]{{}}

\newcounter{mathematicapage}

\newtheorem{p}{Problem}
\usepackage{cancel}
\newtheorem*{lem}{Lemma}
\theoremstyle{definition}
\newtheorem*{dfn}{Definition}
 \newenvironment{s}{%\small%
        \begin{trivlist} \item \textbf{Solution}. }{%
            \hspace*{\fill} $\blacksquare$\end{trivlist}}%


\begin{document}

 {\noindent\Huge\bf  \\[0.5\baselineskip] {\fontfamily{cmr}\selectfont  Homework 1}         }\\[2\baselineskip] % Title
{ {\bf \fontfamily{cmr}\selectfont Quantum Mechanics}\\ {\textit{\fontfamily{cmr}\selectfont     \today}}}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    {\large \textsc{C Seitz}
\\[1.4\baselineskip] 


\begin{p}
1.3.5 Calculations, No-cloning theorem
\end{p}

\begin{s}
Assume we have a unitary copying operator $U$ and two quantum states $\ket{\phi}$ and $\ket{\psi}$. Suppose this unknown copying operator $U$ could transform $\ket{s}$ to either $\ket{\phi}$ or $\ket{\psi}$.

\begin{align*}
\ket{\psi} \otimes \ket{s} \overset{U}{\rightarrow} \ket{\psi} \otimes \ket{\psi}\\
\ket{\phi} \otimes \ket{s} \overset{U}{\rightarrow} \ket{\phi} \otimes \ket{\phi}
\end{align*}

If $U$ is unitary, then it preserves inner products, so

\begin{align*}
(\bra{\psi} \otimes \bra{s})(\ket{\phi} \otimes \ket{s}) &= \bra{\psi}\ket{\phi} \otimes \bra{s}\ket{s} = \bra{\psi}\ket{\phi}
\end{align*}

After the copying transformation, we have

\begin{align*}
(\bra{\psi} \otimes \bra{\psi})(\ket{\phi} \otimes \ket{\phi}) &= \bra{\psi}\ket{\phi}\otimes\bra{\psi}\ket{\phi}\\
&= (\bra{\psi}\ket{\phi})^{2}
\end{align*}

We demanded that the inner product be preserved, so these two results must be equivalent. However, there is only a solution when $\ket{\psi} = \ket{\phi}$ or $\bra{\psi}\ket{\phi} = 0$. Therefore, the copying circuit only works for orthogonal states, and not a general ket.

\end{s}

\begin{p}
1.3.7 Calculations, Quantum Teleportation
\end{p}

\begin{s}

The objective is for Alice to teleport to Bob a qubit in a state $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$, which can be done by using an entangled EPR pair. There three qubits in total: $\ket{\psi}$ and an entangled EPR pair $\ket{\beta_{00}}$. The first qubit in the EPR pair is kept by alice and the second is given to Bob. Since the EPR pair is entangled, the three qubits are in a state

\begin{equation*}
\ket{\psi_{0}} = \frac{1}{\sqrt{2}}\left(\alpha\ket{000} + \alpha\ket{011} + \beta\ket{100} + \beta\ket{111}\right)
\end{equation*}

Alice then sends this state through a CNOT gate, where the qubit $\ket{\psi}$ is the control bit and the first qubit of the EPR pair is the target bit. This of course flips the second bit for the second two terms:

\begin{equation*}
\ket{\psi_{1}} = \frac{1}{\sqrt{2}}\left(\alpha\ket{000} + \alpha\ket{011} + \beta\ket{110} + \beta\ket{101}\right)
\end{equation*}

Then the first qubit is sent through a Hadamard gate. As a minor detour, the Hadamard gate, does

\begin{align*}
\ket{0} &\rightarrow (\ket{0} + \ket{1})/\sqrt{2}\\
\ket{1} &\rightarrow (\ket{0} - \ket{1})/\sqrt{2}
\end{align*}

Therefore, the effect on $\ket{\psi_1}$ is:


\begin{align*}
\ket{\psi_{1}} &= \frac{1}{2}(\alpha\ket{000} + \alpha\ket{100} + \alpha\ket{011} + \alpha\ket{111}\\
&+ \beta\ket{010} + \beta\ket{001} - \beta\ket{110} - \beta\ket{101})\\
&= \frac{1}{2}(\ket{00}(\alpha\ket{0} + \beta\ket{1}) + \ket{10}(\alpha\ket{0} - \beta\ket{1})\\
&+ \ket{01}(\alpha\ket{1} + \beta\ket{0}) + \ket{11}(\alpha\ket{1} - \beta\ket{0})
\end{align*}

Therefore, if Alice measures her two qubits, say in state $\ket{00}$, she can communicate this to bob over a classical communication channel, and Bob then knows the superposition of his qubit. Bob can then apply the necessary quantum gate to transform his qubit to $\ket{\psi} = \alpha\ket{0} + \beta\ket{1}$.

\end{s}

\begin{p}
Deutsch Algorithm, Deutch-Josza Algorithm
\end{p}

\begin{s}

Suppose we have some boolean function $f: \{0,1\} \rightarrow \{0,1\}$. Deutch's algorithm can determine whether the function $f$ is constant or balanced exponentially faster than a classical computer. If $f$ is constant then $f(0) = f(1)$; however, if $f$ is balanced then $f(0)\neq f(1)$. For example, $f(0) = 1$ and $f(1) = 0$ is a balanced function. A classical computer would need to evaluate $f(0)$ and $f(1)$ separately, but a quantum computer can leverage quantum parallelism to compute both $f(0)$ and $f(1)$ at the same time.

\vspace{0.1in}

We start with the two qubits prepared in state $\ket{\psi_{0}} = \ket{0}\ket{1}$. Each qubit is Hadamard transformed to give

\begin{align*}
\ket{\psi_{1}} &= \frac{1}{2}\left(\ket{0} + \ket{1}\right)\left(\ket{0}-\ket{1}\right)\\
&= \frac{1}{2}\left(\ket{0}\ket{0} - \ket{0}\ket{1} + \ket{1}\ket{0} - \ket{1}\ket{1}\right)
\end{align*}

The state then goes through an oracle, which implements the unitary transformation $\ket{\alpha}\ket{\beta} \rightarrow \ket{\alpha}\ket{\beta\oplus f(\alpha)}$. Note that $\oplus$ is addition modulo two, which is essentially an XOR operation. Thus, after transformation, the state is

\begin{align*}
\ket{\psi_{2}} &=  \frac{1}{2}\left(\ket{0}\ket{0\oplus f(0)} - \ket{0}\ket{1\oplus f(0)} + \ket{1}\ket{0\oplus f(1)} - \ket{1}\ket{1\oplus f(1)}\right)\\
&= \frac{1}{2}\left(\ket{0}(\ket{0\oplus f(0)}-\ket{1\oplus f(0)}) + \ket{1}(\ket{0\oplus f(1)}-\ket{1\oplus f(1)})\right)\\
&= \frac{1}{2}\left((-1)^{f(0)}\ket{0}(\ket{0}-\ket{1}) + (-1)^{f(1)}\ket{1}(\ket{0}-\ket{1})\right)\\
\end{align*}

Then we Hadamard transform the first qubit:


\begin{align*}
\ket{\psi_{3}} &=  \frac{1}{2}\left((-1)^{f(0)}(\ket{0}+\ket{1})(\ket{0}-\ket{1}) + (-1)^{f(1)}(\ket{0}-\ket{1})(\ket{0}-\ket{1})\right)\\
&= ((-1)^{f(0)} + (-1)^{f(1)})(\ket{00} - \ket{01}) + ((-1)^{f(0)} - (-1)^{f(1)})(\ket{10} - \ket{11})
\end{align*}

Writing it in this way makes it clear how we determine if the function is constant or balanced. If it is constant($f(0)=f(1)$) then the the second term vanishes. So, if we measure the first qubit, it will be in state $\ket{0}$. However, if it is balanced ($f(0)\neq f(1)$), then the first term vanishes and the first qubit will be measured in state $\ket{1}$.

\vspace{0.1in}

This algorithm generalizes to the case where the function $f: \{0,1\}^{n}\rightarrow \{0,1\}$. This is where the power of quantum computing really shines. Clasically, (if $f$ can be constant or balanced and nothing else), we would need $2^{n-1} + 1$ function calls. But a quantum computer can do this in a single function call. First, note that the Hadamard transform on a bit string $\ket{\alpha}$ of length $n$ is 

\begin{align*}
H\ket{\alpha} = \left(\frac{\ket{0}+\ket{1}}{2}\right)^{\otimes n}
\end{align*}

For brevity, I will now also adopt the notation where $H\ket{0} = \ket{+}$ and $H\ket{1} = \ket{-}$. We have,

\begin{align*}
\ket{\psi_{1}} &= \left(\frac{\ket{0}+\ket{1}}{2}\right)^{\otimes n}\otimes \ket{-} = \frac{1}{2^{n/2}} \sum_{\alpha\in\{0,1\}^{n}} \ket{\alpha}\otimes \ket{-}
\end{align*}

Looking at the last line from $\ket{\psi_{2}}$ in Deutsch's algorithm above, we can see that the effect of the oracle $U$ is efficiently summarized as:

\begin{align*}
U\ket{\alpha}\ket{1} = \frac{1}{2^{n/2}}\sum_{\alpha\in\{0,1\}} (-1)^{f(\alpha)}\ket{\alpha}\ket{-}
\end{align*}

Therefore, for the $n$-bit case, we get

\begin{align*}
\ket{\psi_{2}} &= \frac{1}{2^{n/2}} \sum_{\alpha\in\{0,1\}^{n}} (-1)^{f(\alpha)}\ket{\alpha}\otimes \ket{-}
\end{align*}



\end{s}

\end{document}